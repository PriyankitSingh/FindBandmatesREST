package nz.ac.auckland.parolee.test;

import static org.junit.Assert.*;

import java.util.Calendar;
import java.util.List;

import javax.persistence.EntityManager;
import javax.persistence.EntityManagerFactory;
import javax.persistence.Persistence;

import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import nz.ac.auckland.musician.domain.Experience;
import nz.ac.auckland.musician.domain.Instrument;
import nz.ac.auckland.musician.domain.Musician;
import nz.ac.auckland.musician.domain.PersistanceManager;
import nz.ac.auckland.parolee.domain.Gender;

public class MusicianPersistanceTest {
	
	private Logger logger = LoggerFactory.getLogger(MusicianPersistanceTest.class);
	private EntityManagerFactory entityManagerFactory;
	
	/**
	 * Runs before each test to create a new EntityManagerFactory.
	 * 
	 */
	@Before
	public void setUp() throws Exception {
		// Create an EntityManagerFactory from which an EntityManager can be 
		// requested. The argument to createEntityManagerFactory() is the name
		// of a persistence unit, named in META-INF/persistence.xml. The 
		// factory configures itself based on reading the xml file. 
		// persistence.xml must contain a persistence unit named, in this case,
		// "nz.ac.auckland.hello".
		entityManagerFactory = Persistence.createEntityManagerFactory( "musicianPersistance" );
	}

	/**
	 * Runs after each test to destroy the EntityManagerFactory.
	 * 
	 */
	@After
	public void tearDown() throws Exception {
		// Close the EntityManagerFactory once all tests have executed.
		entityManagerFactory.close();
	}
	
	/**
	 * Illustrates use of the JPA EntityManager. This test uses a transaction 
	 * to store a Message object in the database. It then uses another
	 * transaction to query the database for Messages. It prints the Message,
	 * changes its state and updates the database. 
	 */
	@Test
	public void testBasicUsage() {
		// Acquire an EntityManager, representing a session with the database.
		// Using the entityManager, create a transaction.
		EntityManager entityManager = entityManagerFactory.createEntityManager();
		entityManager.getTransaction().begin();
		
		// create 1st user
		Calendar cal = Calendar.getInstance();
		cal.set(1963, 8, 3);
		Musician het = new Musician(1, "Hetfield", "James", Gender.MALE, Experience.PROFESSIONAL, cal, Instrument.GUITAR);
		
		// Request the the EntityManager stores the Message.
		entityManager.persist(het);
		
		// Commit the transaction. This causes the JPA provider to execute the
		// SQL statement: 
		//   insert into MESSAGE (ID, TEXT) values (1, 'Hello, World!')
		entityManager.getTransaction().commit();

		// Now let's pull the Message from the database. Start a new 
		// transaction. 
		entityManager.getTransaction().begin();
		
		// Query the database for stored Messages. The query is expressed using
		// JPQL (Java Persistence Query Language) which looks similar to SQL. 
		// Rather than being written in terms of tables and columns, JPQL 
		// queries are written in terms of classes and properties. This JPQL
		// query generates the SQL query: select * from MESSAGE.
        List<Musician> musicians = entityManager.createQuery("select m from Musician m", Musician.class).getResultList();
		for (Musician m : musicians ) {
			logger.info("Message: " + m);
		}
		// They query should return one Message object.
		assertEquals(1, musicians.size());
		
		// The text of the returned Message should be what was originally 
		// persisted.
		Musician retrievedMusician = musicians.get(0);
		assertEquals("James", retrievedMusician.getFirstname());
		
		// The query actually returns a reference to the original Message
		// object. This is because the persistence context is managing the
		// original object. If a query returns an object that is already
		// managed by the persistence context, a separate copy of the object
		// isn't made.
		assertSame(het, retrievedMusician);
		
		cal.set(1994, 7, 3);
		Musician pri = new Musician(2, "Singh", "Priyankit", Gender.MALE, Experience.ADVANCED, cal, Instrument.GUITAR);
		
		// When this transaction commits, the following SQL is executed:
		//   update MESSAGE set TEXT = 'Take me to your leader!' where ID = 1
        entityManager.getTransaction().commit();
        entityManager.close();
	}
	
	@Test
	public void testMusicianPersistance(){
		logger.info("Starting test");
		PersistanceManager2 manager = new PersistanceManager2();
		
		Calendar cal = Calendar.getInstance();
		cal.set(1963, 8, 3);
		Musician het = new Musician(1, "Hetfield", "James", Gender.MALE, Experience.PROFESSIONAL, cal, Instrument.GUITAR);
		
		cal.set(1994, 7, 3);
		Musician pri = new Musician(2, "Singh", "Priyankit", Gender.MALE, Experience.ADVANCED, cal, Instrument.GUITAR);
		
		manager.addMusicianToDatabase(het);
		manager.addMusicianToDatabase(pri);
		
		// Query the database here
	}

}
